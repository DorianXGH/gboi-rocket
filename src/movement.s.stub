.DEFINE ISAACHITBOX 1

move_stub:
; //////// MOVE ISAAC  Y \\\\\\\
	ld a,(global_.isaac.speed)
	and %00001111
	bit $3,a
	jp z,@dy_pos
	or %11110000
@dy_pos:
	ld hl,global_.isaac.y
	add (hl)
	ld (hl),a
; \\\\\\\ MOVE ISAAC  Y ////////

; //////// Collision \\\\\\\
	ld a, (global_.isaac.x)
	ld (collision_.p.1.x), a
	ld a, (global_.isaac.y)
	ld (collision_.p.1.y), a
	ld a, ISAACHITBOX
	ld (collision_.hitbox1), a

	; /// loop start \\\
	ld de, movement_stub_.collisions
	ld a, d
	ld (movement_stub_.next_coll), a
	ld a, e
	ld (movement_stub_.next_coll + 1), a
	ld hl, global_.elements
	ld c, n_elements
@@loop:
	; \\\ loop start ///

	; /// init result \\\
	ld a, (movement_stub_.next_coll)
	ld d, a
	ld a, (movement_stub_.next_coll + 1)
	ld e, a
	ld a, %00000000
	ld (de), a
	; \\\ init result ///

	; /// set position as parameter \\\
	ldi a, (hl)
	ld (collision_.p.2.x), a
	ldi a, (hl)
	ld (collision_.p.2.y), a
	; \\\ set position as parameter ///
	
	; /// set hitbox as parameter \\\
	inc hl
	ld a, (hl)
	ld de, global_.sheets
	ld e,a
	ld a, (de)	; a = (*element.sheet).size)
	and %00000111
	ld (collision_.hitbox2), a
	; \\\ set hitbox as parameter ///

	; /// test collision \\\
	ld d, h
	ld e, l
	call collision
	ld h, d
	ld l, e

	and a
	jr z, @@noCollision
	ld a, (movement_stub_.next_coll)
	ld d, a
	ld a, (movement_stub_.next_coll + 1)
	ld e, a
	ld a, (de)
	set $6, a
	ld (de), a
	; \\\ test collision ///
@@noCollision:

	; /// loop end \\\
	ld de, $0004
	add hl, de

	; // update position of next result \\
	ld a, (movement_stub_.next_coll)
	ld d, a
	ld a, (movement_stub_.next_coll + 1)
	ld e, a
	inc de
	inc de
	ld a, d
	ld (movement_stub_.next_coll), a
	ld a, e
	ld (movement_stub_.next_coll + 1), a
	; \\ update position of next result //

	dec c
	jr nz, @@loop
	; \\\ loop end ///
; \\\\\\\ Collision ////////

; //////// MOVE ISAAC  X \\\\\\\
	ld a,(global_.isaac.speed)
	and %11110000
	swap a
	and %00001111
	bit $3,a
	jp z,@dx_pos
	or %11110000
@dx_pos:
	ld hl,global_.isaac.x
	add (hl)
	ld (hl),a
; \\\\\\\ MOVE ISAAC  X ////////

; //////// Collision \\\\\\\
	ld a, (global_.isaac.x)
	ld (collision_.p.1.x), a
	ld a, (global_.isaac.y)
	ld (collision_.p.1.y), a
	ld a, ISAACHITBOX
	ld (collision_.hitbox1), a

	; /// loop start \\\
	ld de, movement_stub_.collisions
	ld a, d
	ld (movement_stub_.next_coll), a
	ld a, e
	ld (movement_stub_.next_coll + 1), a
	ld hl, global_.elements
	ld c, n_elements
@@loop:
	; \\\ loop start ///

	; /// set position as parameter \\\
	ldi a, (hl)
	ld (collision_.p.2.x), a
	ldi a, (hl)
	ld (collision_.p.2.y), a
	; \\\ set position as parameter ///
	
	; /// set hitbox as parameter \\\
	inc hl
	ld a, (hl)
	ld de, global_.sheets
	ld e,a
	ld a, (de)	; a = (*element.sheet).size)
	and %00000111
	ld (collision_.hitbox2), a
	; \\\ set hitbox as parameter ///

	; /// test collision \\\
	ld d, h
	ld e, l
	call collision
	ld h, d
	ld l, e
	and a
	jr z, @@noCollision
	ld a, (movement_stub_.next_coll)
	ld d, a
	ld a, (movement_stub_.next_coll + 1)
	ld e, a
	ld a, (de)
	set $7, a
	ld (de), a
	; \\\ test collision ///
@@noCollision:

	; /// loop end \\\
	ld de, $0004
	add hl, de

	; // update position of next result \\
	ld a, (movement_stub_.next_coll)
	ld d, a
	ld a, (movement_stub_.next_coll + 1)
	ld e, a
	inc de
	inc de
	ld a, d
	ld (movement_stub_.next_coll), a
	ld a, e
	ld (movement_stub_.next_coll + 1), a
	; \\ update position of next result //

	dec c
	jr nz, @@loop
	; \\\ loop end ///
; \\\\\\\ Collision ////////

@collision_solver:
; //////// call collision solver \\\\\\\
	; /// loop start \\\
	ld hl, movement_stub_.collisions
	ld a, h
	ld (movement_stub_.next_coll), a
	ld a, l
	ld (movement_stub_.next_coll + 1), a
	ld de, global_.elements
	ld c, n_elements
@@loop:
	; \\\ loop start ///

	inc de
	inc de
	inc de ; points on element.sheet
	ld a, (movement_stub_.next_coll)
	ld h, a
	ld a, (movement_stub_.next_coll + 1)
	ld l, a
	ld a, (hl)
	ld b, a
	and a
	jp z,@@dont_call
	ld hl,global_.sheets
	ld a,(de)
	ld l,a
	call collisionSolverIsaac
@@dont_call:

	; /// loop end \\\
	ld hl, $0004
	add hl, de
	ld d, h
	ld e, l

	; // update position of next result \\
	ld a, (movement_stub_.next_coll)
	ld h, a
	ld a, (movement_stub_.next_coll + 1)
	ld l, a
	inc hl
	inc hl
	ld a, h
	ld (movement_stub_.next_coll), a
	ld a, l
	ld (movement_stub_.next_coll + 1), a
	; \\ update position of next result //

	dec c
	jr nz, @@loop
	; \\\ loop end ///
; \\\\\\\ call collision solver ////////

; //////// TEST A B \\\\\\\
; if A / B are pressed
;	ld hl, global_.isaac.tears
;	bit $7,(hl); flag A set
;	jr z,@Aset
;	ld a,$10
;	ld (global_.isaac.x),a
;	ld (global_.isaac.y),a
;@Aset:
;
;	bit $6,(hl); flag B set
;	jr z,@Bset
;	ld a,$90
;	ld (global_.isaac.x),a
;	ld (global_.isaac.y),a
;@Bset:
; \\\\\\\ TEST A B ////////
